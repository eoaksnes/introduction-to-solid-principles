<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h2>SOLID</h2>
					<div>A term describing a collection of design principles for good code that was coined by Robert C. Martin also known as Uncle Bob.</div>
					<img src="./assets/clean-books.png" />
				</section>

				<section>
					<h2>Disclaimer</h2>
					<div>These are principles, not laws!</div>
				</section>

				<section>
					<section>
						<h2>Single responsibility principle</h2>
						<img style="width: 600px" src="./assets/single-responsibility-principle2.png" />
					</section>

					<section>
						<blockquote>
							A class should have only one responsibility and there should be only one reason why you want to change the class.
						</blockquote>
						<aside class="notes">
							If a Class has many responsibilities, it increases the possibility of bugs because making changes to one of its responsibilities, could affect the other ones without you knowing.
						</aside>
					</section>

					<section>
						<h2>What does that mean?</h2>
						<div>Do one thing and do it well!</div>
					<aside class="notes">
						<div>“…You had one job” - Loki to Skurge in Thor: Ragnarok</div>
						<div><a href="https://www.youtube.com/watch?v=4Y0tOi7QWqM">“Fits In My Head“</a> - Dan North</div>

						Write classes so that your code fits in your head.
					</aside>
					</section>

					<section>
					  <h3>Is this a violation?</h3>
					  <div class="mermaid">
						<pre>
						  %%{init: {'theme': 'dark', 'themeVariables': { 'darkMode': true }}}%%
						  classDiagram
							class Person{
							  +String name
							  -save_db()
							}
						</pre>
					  </div>
					  <div>This Person class has two jobs?</div>
					  <aside class="notes">
					  <ul>
						  <li>Manage the person’s property</li>
						  <li>Store the person in the database</li>
					   </ul>
					  </aside>
					</section>

					<section>
					  <h3>Better?</h3>
					  <div class="mermaid">
						<pre>
						  %%{init: {'theme': 'dark', 'themeVariables': { 'darkMode': true }}}%%
						  classDiagram
							Person <|-- PersonDB
							class Person{
							  +String name
							}
							class PersonDB{
							  -save()
							}
						</pre>
					  </div>
					  <aside class="notes">
					  	<div>Separate the Person class into two classes.</div>
						<ul>
							<li>The Person class is responsible for managing the person’s properties.</li>
							<li>The PersonDB class is responsible for storing the person in the database.</li>
						</ul>
					  </aside>
					</section>

					<section>
						<h2>Guideline</h2>
						<div>Gather together the things that change for the same reasons. Separate those things that change for different reasons.</div>
						<img style="width: 200px" src="./assets/single-responsibility-principle.png" />
						<aside class="notes"> A simple way to implement this is to group together methods and attributes that are going to change for the same reason. This allows us to write modular code that is easily maintainable and testable.</aside>
					</section>

					<section>
						<h2>How to spot violations</h2>
						<div>
							If you describe what a piece of code does with an “AND”, it’s probably violating the principle.
						</div>
					</section>

					<section>
						<h2>Some signs of violations</h2>
						<img style="width: 200px" src="./assets/single-responsibility-principle3.gif" />
						<ul class="r-fit-text">
							<li>
								If statements/switch statements where each case represent one responsibility/reasons to change
								<ul>
									<li>Fix: extract the logic to a separate method or class</li>
								</ul>
							</li>
							<li>
								Monster methods that does more than one thing
								<ul>
									<li>Fix: split it into multiple methods or classes that do just one thing</li>
								</ul>
							</li>
							<li>
								God class that contains everything in a single class
								<ul>
									<li>
										Fix: split into specialized classes that handle clear use cases
									</li>
								</ul>
							</li>
						</ul>
					</section>

					<section>
						<h2>Benefits</h2>
						<ul class="r-fit-text">
							<li>
								The code is easier to understand (does only one thing)
								<ul>
									<li>
										We spend 90% of our time as software developer reading code, so it’s pretty important to be able to understand it and reason about it very fast.
									</li>
								</ul>
							</li>
							<li>The code is easier to test (less test cases)</li>
							<li>The code is less fragile (changes are isolated) and therefore easier to maintain</li>
							<li>The code is more reusable (the code should be reusable without modification)</li>
							<li>The code becomes more decoupled</li>
						</ul>
					</section>

					<section>
						<h2>References</h2>
						<ul class="r-fit-text">
							<li>React: https://konstantinlebedev.com/solid-in-react/</li>
							<li>https://ducmanhphan.github.io/2020-01-17-Understanding-about-SOLID-part-1/</li>
							<li>https://www.pythontutorial.net/python-oop/python-single-responsibility-principle/</li>
							<li>https://www.robertopiva.pro/2016/12/30/how-to-spot-single-responsibility-principle-violation.html</li>
							<li>https://www.linkedin.com/pulse/spotting-single-responsibility-violations-code-stuart-dobson/</li>
							<li>Patterns: https://ericbackhage.net/clean-code/solid-the-single-responsibility-principle/</li>
						</ul>
					</section>
				</section>

				<section>
					<section>
						Open-closed principle
						<img style="width: 600px" src="./assets/open-closed principle.png"/>
					</section>
					<section>
						<blockquote>
							A software module (can be a class or method) should be open for extension but closed for modification.
						</blockquote>
						<aside class="notes">
							Robert C. Martin considered this principle "the most important principle of object-oriented design"
						</aside>
					</section>

					<section>
						<h2>But what does that mean?</h2>
						<blockquote>
							Simply, it means that if your business requirements change you shouldn’t modify the existing code (closed for modifications). Instead, you should add a new code that extends the existing code without affecting it (open for extension).
						</blockquote>
					</section>

					<section>
					  <h3>Is this a violation?</h3>
					  <div class="mermaid">
						<pre>
						  %%{init: {'theme': 'dark', 'themeVariables': { 'darkMode': true }}}%%
						  classDiagram
							Person <|-- PersonStorage
							class Person{
							  +String name
							}
							class PersonStorage{
							  -save_to_database()
							  -save_to_json()
							}

						</pre>
					  </div>
					  <aside class="notes">
						If you want to save the Person’s object into an XML file, you must modify the PersonStorage class.
						It means that the PersonStorage class is not open for extension but modification.
						Hence, it violates the open-closed principle.
					  </aside>
					</section>

					<section data-visibility="hidden">
						<pre><code class="hljs python" data-trim data-line-numbers>
						class Person:
							def __init__(self, name):
								self.name = name

							def __repr__(self):
								return f'Person(name={self.name})'


						class PersonStorage:
							def save_to_database(self, person):
								print(f'Save the {person} to database')

							def save_to_json(self, person):
								print(f'Save the {person} to a JSON file')


						if __name__ == '__main__':
							person = Person('John Doe')
							storage = PersonStorage()
							storage.save_to_database(person)
						</code></pre>
					</section>

					<section>
						<h2>Better?</h2>
						<div class="mermaid">
						<pre>
						  %%{init: {'theme': 'dark', 'themeVariables': { 'darkMode': true }}}%%
						  classDiagram
							Person <-- PersonStorage
							PersonStorage <|-- PersonJSON
							PersonStorage <|-- PersonDB
							class Person{
							  +String name
							}
							class PersonStorage{
							  -save()
							}
							class PersonJSON{
							  -save()
							}
							class PersonDB{
							  -save()
							}
						</pre>
					  </div>
					</section>

					<section data-visibility="hidden">
						<pre><code class="hljs python" data-trim data-line-numbers>
from abc import ABC, abstractmethod

class Person:
    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return f'Person(name={self.name})'


class PersonStorage(ABC):
    @abstractmethod
    def save(self, person):
        pass


class PersonDB(PersonStorage):
    def save(self, person):
        print(f'Save the {person} to database')


class PersonJSON(PersonStorage):
    def save(self, person):
        print(f'Save the {person} to a JSON file')


if __name__ == '__main__':
    person = Person('John Doe')
    storage = PersonDB()
    storage.save(person)

						</code></pre>
					</section>

					<section>
						<h2>Guideline</h2>
						<ul class="r-fit-text">
							<li>
								 The object-oriented programming way to do this is using inheritance
								<ul>
									<li>Create a subclass and override any desired methods and properties.</li>
								</ul>
							</li>
							<li>
								Realised through the usage of interfaces (hide every special implementation behind an interface)
								<ul>
									<li>
										An elegant way to avoid breaking the principle, if applicable, is to use interfaces as parameters for classes and implement our logic using those interfaces (strategy pattern).
									</li>
								</ul>
							</li>
						</ul>
						<img style="width: 200px" src="./assets/open-closed-principle2.png" />
						<aside class="notes">
							https://www.linkedin.com/pulse/solid-design-principles-open-closed-principle-ocp-amritpal-singh/
							https://ericbackhage.net/clean-code/solid-the-open-closed-principle/
						</aside>
					</section>

					<section data-visibility="hidden">
						<blockquote>
							The purpose of the open-closed principle is to make it easy to add new features (or use cases) to the system without directly modifying (breaking) the existing code.
						</blockquote>
					</section>

					<section>
						<h2>How to spot violations</h2>
						<div class="r-fit-text">You are violating this principle if you directly work with a concrete implementation instead of an abstraction. The violation becomes visible when you must extend existing code to accommodate new functionality.</div>
					</section>

					<section>
						<h2>Some signs of violations</h2>
						<ul class="r-fit-text">
							<li>You have private methods that almost do the same thing (but with a slight variation in the implementation)</li>
							<li>You use (a lot of) ifs to control behavior, e.g. doing something the old way or the new way.</li>
							<li>You use an abstract class but check for the concrete implementation to control flow (methods that adjust logic based on instance types)</li>
						</ul>
					</section>

					<section>
						<h2>Warning?</h2>
						<div>Premature optimization can introduce uncessary complexity. If you extend the export class when you have just pdf then we are introducing unnecessary complexity</div>
					</section>

					<section>
						<h2>Benefits</h2>
						<ul class="r-fit-text">
							<li>Reduce testing of existing code. The less you change the existing code, the less it would introduce new bugs.</li>
							<li>Reduce the cost of a business change requirement.</li>
						</ul>
					</section>

					<section>
						<h2>Template Method Pattern</h2>
						<div class="r-fit-text">Create an abstract class containing the base logic, and create implementations of it for different behavior. If you want to add new behavior, you simply create a new class, derive from the base class and add the functionality. </div>
						<img src="./assets/template-method-pattern.png" />
					</section>

					<section>
						<h2>Decorator Pattern</h2>
						<div class="r-fit-text">If you want to extend functionality (do the original thing and something extra before and/or after) but not want to change the existing class.</div>
						<a href="https://alexnault.dev/open-closed-principle-in-functional-typescript">Example in React</a>
						<a href="https://dev.to/shadid12/why-apply-open-closed-principles-in-react-component-composition-26p1">Example in React</a>
						<img src="./assets/decorator-pattern.png" />
					</section>

					<section>
						<h2>Strategy Design Pattern</h2>
						<div class="r-fit-text">One way is to create an interface (or abstract class) for the behavior, implement the interface for a certain behavior and use the interface from the calling class. </div>
						<img src="./assets/strategy-design-pattern.png" />
						<div class="r-fit-text">The strategy design pattern is a great example that achieves the OCP in an elegant way. It is one of the most useful design patterns.</div>
						<aside class="notes">
							You have a problem that can be solved in multiple ways. These ways are called Strategies, every strategy encapsulates a different solution for the problem. All these strategies must implement one interface to solve this problem. This problem is in a class called Context. These strategies can be injected into the context in many ways like Dependency Injection, Factory Design Pattern, or simply, by If Condition.
							Now, your code is open for extensions as it enables you to use different strategies as long as they implement the required interface. And closed for modifications because the context class itself doesn’t have to be changed, it solves its problem with any strategy, no matter what exactly the strategy is.
					   </aside>
					</section>


					<section>
						<h2>References</h2>
						<ul class="r-fit-text">
							<li>https://blog.mayallo.com/open-closed-principle-the-hard-parts</li>
							<li>https://thevaluable.dev/open-closed-principle-revisited/</li>
							<li>https://stackoverflow.com/questions/59016/what-is-the-meaning-and-reasoning-behind-the-open-closed-principle</li>
							<li>https://www.devonblog.com/software-development/solid-violations-in-the-wild-the-open-closed-principle/</li>
							<li>https://ezzeddinabdullah.com/post/solid-principles-ocp-py/</li>
							<li>https://ericbackhage.net/clean-code/solid-the-open-closed-principle/</li>
							<li>https://www.devonblog.com/software-development/solid-violations-in-the-wild-the-open-closed-principle/</li>
							<li>https://waldemar.bearblog.dev/open-closed-principle/</li>
							<li>https://michalgodkowicz.medium.com/how-to-make-your-python-code-maintainable-with-the-open-close-principle-1860fecc8ec0</li>
						</ul>
					</section>

				</section>

				<section>
					<section>
						Liskov’s substitution principle
					<img style="width: 600px" src="./assets/liskov-substitution-principle2.webp"/>
					</section>

					<section>
						<blockquote>
							Objects in a program should be replaceable with instances of their subtypes <b>without altering the correctness</b> of the program.
						</blockquote>
					</section>

					<section>
						<h2>What does that mean?</h2>
						<blockquote>
							In simpler terms, subclasses must behave like base classes.
						</blockquote>
						<blockquote>
							If S is a subtype of T, then objects of type T in a program may be replaced with objects of type S without altering any of the desirable properties of that program.
						</blockquote>
					</section>

					<section>
						<h2>Typescript</h2>
						<pre>
							<code class="hljs javascript" data-trim data-line-numbers>
const isEven = (x: number) : boolean => x % 2 == 0;
const isOdd = (x: number) : boolean => x % 2 == 1;

const printFiltered = (arr: number[], filterFunc: (int) => boolean) => {
 arr.forEach((item) => {
   if (filterFunc(item)) {
     console.log(item);
   }
 })
}

const array = [1, 2, 3, 4, 5, 6];
printFiltered(array, isEven);
printFiltered(array, isOdd);
							</code>
						</pre>
					</section>

					<section>
						<h2>Benefits</h2>
						<ul>
							<li>
								 Security that an implementation can be replaced without changing its behavior.
							</li>
							<li>
								This principle aims to enforce consistency so that the parent Class or its child Class can be used in the same way without any errors.
							</li>
						</ul>
					</section>

				</section>

				<section>
					<section>
						Interface Segregation Principle
						<img src="./assets/interface-sgregation-principle2.webp"/>
					</section>

					<section>
						<blockquote>
							Clients should not be forced to depend upon the interfaces that they do not use.
						</blockquote>
						<aside class="notes">
						<div>
							Many client-specific interfaces are better than one general-purpose interface.
						</div>
						<div>
							Each class should be focused on one aspect or topic only
						</div>
						</aside>
					</section>

					<section>
						<h2>What does that mean?</h2>
						<blockquote>Keep your interfaces the smallest you can. No client should be forced to depend on methods it does not use.</blockquote>
						<aside class="notes">
							<div>Clients should not be forced to depend on methods that they do not use.</div>
						</aside>
					</section>

					<section>
						<h2>Guideline</h2>
						<div>
							Do not let interfaces become large in the first place and divide them into many small interfaces beforehand. This allows much more targeted interfaces to be defined externally.
						</div>
						<aside class="notes">
							The Interface Segregation Principle deals with the separation or decoupling of classes. In the Open-Closed Principle, we learned to work with interfaces. However, interfaces are not without problems either, as they usually tend to get bigger and bigger. As a result, it becomes increasingly difficult to provide a complete implementation as more and more code needs to be added.
						</aside>
					</section>

					<section>
						<h2>Benefits</h2>
						<ul>
						️    <li>This principle aims at splitting a set of actions into smaller sets so that a Class executes ONLY the set of actions it requires.</li>
						</ul>
					</section>

				</section>

				<section>
					<section>
						<h2>Dependency Inversion Principle</h2>
						<img style="width: 600px" src="./assets/dependency-inversion-principle2.webp"/>
					</section>

					<section>
						<blockquote>
							High level modules <b>should not depend upon low level</b> modules. Both <b>should depend upon abstractions</b>.
							Abstractions should not depend upon details. Details should depend upon abstractions.
						</blockquote>
					</section>

					<section>
						<h2>What does this mean?</h2>
						<div>Objects should not instantiate their dependencies, but they should be passed to them.</div>
					</section>

					<section>
						<h2>Benefits</h2>
						<ul>
							<li>It decouples the dependencies.</li>
						</ul>
					</section>
				</section>

				<section>
					<h2>The principles</h2>
					<table  class="r-fit-text">
					  <tr>
						<td>Single responsibility</td>
						<td>Don’t mix unrelated responsibilities</td>
					  </tr>
						<tr>
							<td>Open-closed</td>
							<td>When adding new features, avoid doing a lot of changes in the existing code</td>
						</tr>
						<tr>
							<td>Liskov’s substitution</td>
							<td>When adding new features, avoid doing a lot of changes in the existing code</td>
						</tr>
						<tr>
							<td>Interface Segregation</td>
							<td>When using an interface, don’t make me implement methods that don’t make sense</td>
						</tr>
						<tr>
							<td>Dependency Inversion Principle</td>
							<td>Objects should not instantiate their dependencies, but they should be passed to them.</td>
						</tr>
					</table>
				</section>

				<section data-visibility="hidden">
					<h2>STUPID</h2>
					<div>singleton invasion, tight coupling, untestability, premature optimization, indescriptive naming and duplication</div>
					http://slides.williamdurand.fr/from-stupid-to-solid-code/#/2
				</section>

				<section>
					<h2>References</h2>
					<ul>
						<li>
							https://camao-tec.com/en/solid-principles-easily-explained/
						</li>
						<li>
							https://www.pythontutorial.net/python-oop/python-open-closed-principle/
						</li>
						<li>
							https://medium.com/backticks-tildes/the-s-o-l-i-d-principles-in-pictures-b34ce2f1e898
						</li>
						<li>
							https://codeburst.io/understanding-solid-principles-open-closed-principle-e2b588b6491f
						</li>
					</ul>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/reveal.js-mermaid-plugin@1.1.0/plugin/mermaid/mermaid.js"></script>

		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMermaid ]
			});
		</script>
	</body>
</html>
