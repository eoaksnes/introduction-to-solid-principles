<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<section>
						<h2>Single responsibility principle</h2>
						<img src="./assets/single-responsibility-principle2.png" />
					</section>

					<section>
						<blockquote>
							A class should have only one responsibility and there should be only one reason why you want to change the class. Do one thing and do it well!
						</blockquote>
						<img style="width: 200px" src="./assets/single-responsibility-principle.png" />
						<aside class="notes">
						</aside>
					</section>

					<section>
					  <h3>Is this correct?</h3>
					  <div class="mermaid">
						<pre>
						  %%{init: {'theme': 'dark', 'themeVariables': { 'darkMode': true }}}%%
						  classDiagram
							class Person{
							  +String name
							  -save()
							}
						</pre>
					  </div>
					  <div>This Person class has two jobs</div>
					  <ul>
						  <li>Manage the person’s property.</li>
						  <li>Store the person in the database.</li>
					  </ul>
					</section>

					<section>
					  <h3>Is this correct?</h3>
					  <div class="mermaid">
						<pre>
						  %%{init: {'theme': 'dark', 'themeVariables': { 'darkMode': true }}}%%
						  classDiagram
							Person <|-- PersonDB
							class Person{
							  +String name
							}
							class PersonDB{
							  -save()
							}
						</pre>
					  </div>
					  <div>Separate the Person class into two classes.</div>
						<ul>
							<li>The Person class is responsible for managing the person’s properties.</li>
							<li>The PersonDB class is responsible for storing the person in the database.</li>
						</ul>
					  <aside class="notes">
					  </aside>
					</section>

					<section>
						<h2>How to spot violations</h2>
						<div>
							When designing classes, you should put related methods that have the same reason for change together. In other words, you should separate classes if they change for different reasons.
						</div>
					</section>

					<section>
						<h2>Some signs of violations</h2>
						<ul class="r-fit-text">
							<li>If statements and switch statements (can have multiple reasons to change where each case represent one responsibility)</li>
							<li>Monster methods (does more than one thing)</li>
							<li>God class (everything in a single class)</li>
						</ul>
					</section>

					<section>
						<h2>Benefits</h2>
						<ul class="r-fit-text">
							<li>
								The code is easier to understand (does only one thing)
								<ul>
									<li>
										We spend 90% of our time as software developer reading code, so it’s pretty important to be able to understand it and reason about it very fast.
									</li>
								</ul>
							</li>
							<li>The code is easier to test (less test cases)</li>
							<li>The code is less fragile (changes are isolated) and therefore easier to maintain</li>
							<li>The code is more reusable (the code should be reusable without modification)</li>
							<li>The code becomes more decoupled</li>
						</ul>
					</section>

					<section>
						<h2>References</h2>
						<ul>
							<li>https://konstantinlebedev.com/solid-in-react/</li>
							<li>https://ducmanhphan.github.io/2020-01-17-Understanding-about-SOLID-part-1/</li>
							<li>https://www.pythontutorial.net/python-oop/python-single-responsibility-principle/</li>
						</ul>
					</section>
				</section>

				<section>
					<section>
						Open-closed principle
						<img src="./assets/open-closed principle.png"/>
					</section>
					<section>
						<blockquote>
							The open-closed principle states that a class, method, and function should be open for extension but closed for modification.
						</blockquote>
						<img style="width: 200px" src="./assets/open-closed-principle2.png" />
						<aside class="notes">
							Robert C. Martin considered this principle "the most important principle of object-oriented design"
						</aside>
					</section>

					<section>
						<h2>But what does that mean?</h2>
						<blockquote>
							Simply, it means that if your business requirements change you shouldn’t modify the existing code (closed for modifications). Instead, you should add a new code that extends the existing code without affecting it (open for extension).
						</blockquote>
					</section>

					<section>
						<h2>How can this be achieved?</h2>
						<ul class="r-fit-text">
							<li>
								 The object-oriented programming way to do this is using inheritance: create a subclass and override any desired methods and properties.
							</li>
							<li>
								An elegant way to avoid breaking the principle, if applicable, is to use interfaces as parameters for classes and implement our logic using those interfaces (strategy pattern).
							</li>
						</ul>
						<aside class="notes">
							 Use the <a href="https://forums.kodeco.com/t/how-is-strategy-pattern-different-from-the-open-closed-principle/66239/3">strategy pattern</a>.
							https://dev.to/abh1navv/how-solid-is-your-code-open-closed-principle-3k68
							Hide every special implementation behind an interface.
							Realised through the usage of interfaces.
							https://www.linkedin.com/pulse/solid-design-principles-open-closed-principle-ocp-amritpal-singh/
							https://ericbackhage.net/clean-code/solid-the-open-closed-principle/
							Object-oriented: This works – you’re not modifying the code of the base class, so it satisfies OCP – but is it the best option? It may not be! For example, if you need to override the same methods with the same behavior in multiple subclasses, you’d wind up duplicating code if you only use inheritance.
						</aside>
					</section>

					<section>
					  <h3>Is this correct?</h3>
					  <div class="mermaid">
						<pre>
						  %%{init: {'theme': 'dark', 'themeVariables': { 'darkMode': true }}}%%
						  classDiagram
							Person <|-- PersonStorage
							class Person{
							  +String name
							}
							class PersonStorage{
							  -save_to_database()
							  -save_to_json()
							}

						</pre>
					  </div>
					  <aside class="notes">
						If you want to save the Person’s object into an XML file, you must modify the PersonStorage class.
						It means that the PersonStorage class is not open for extension but modification.
						Hence, it violates the open-closed principle.
					  </aside>
					</section>

					<section data-visibility="hidden">
						<pre><code class="hljs python" data-trim data-line-numbers>
						class Person:
							def __init__(self, name):
								self.name = name

							def __repr__(self):
								return f'Person(name={self.name})'


						class PersonStorage:
							def save_to_database(self, person):
								print(f'Save the {person} to database')

							def save_to_json(self, person):
								print(f'Save the {person} to a JSON file')


						if __name__ == '__main__':
							person = Person('John Doe')
							storage = PersonStorage()
							storage.save_to_database(person)
						</code></pre>
					</section>

					<section>
						<div class="mermaid">
						<pre>
						  %%{init: {'theme': 'dark', 'themeVariables': { 'darkMode': true }}}%%
						  classDiagram
							Person <-- PersonStorage
							PersonStorage <|-- PersonJSON
							PersonStorage <|-- PersonDB
							class Person{
							  +String name
							}
							class PersonStorage{
							  -save()
							}
							class PersonJSON{
							  -save()
							}
							class PersonDB{
							  -save()
							}
						</pre>
					  </div>
					</section>

					<section data-visibility="hidden">
						<pre><code class="hljs python" data-trim data-line-numbers>
from abc import ABC, abstractmethod

class Person:
    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return f'Person(name={self.name})'


class PersonStorage(ABC):
    @abstractmethod
    def save(self, person):
        pass


class PersonDB(PersonStorage):
    def save(self, person):
        print(f'Save the {person} to database')


class PersonJSON(PersonStorage):
    def save(self, person):
        print(f'Save the {person} to a JSON file')


if __name__ == '__main__':
    person = Person('John Doe')
    storage = PersonDB()
    storage.save(person)

						</code></pre>
					</section>

					<section>
						<blockquote>
							The purpose of the open-closed principle is to make it easy to add new features (or use cases) to the system without directly modifying (breaking) the existing code.
						</blockquote>
					</section>

					<section>
						<h2>How to spot violations</h2>
						<div class="r-fit-text">You are violating this principle if you directly work with a concrete implementation instead of an abstraction. The violation becomes visible when you must extend existing code to accommodate new functionality.</div>
					</section>

					<section>
						<h2>Some signs of violations</h2>
						<ul class="r-fit-text">
							<li>You have private methods that almost do the same thing (but with a slight variation in the implementation)</li>
							<li>You use (a lot of) ifs to control behavior, e.g. doing something the old way or the new way.</li>
							<li>You use an abstract class but check for the concrete implementation to control flow (methods that adjust logic based on instance types)</li>
						</ul>
					</section>

					<section>
						<h2>Warning?</h2>
						<div>Premature optimization can introduce uncessary complexity. If you extend the export class when you have just pdf then we are introducing unnecessary complexity</div>
					</section>

					<section>
						<h2>Benefits</h2>
						<ul class="r-fit-text">
							<li>Reduce testing of existing code. The less you change the existing code, the less it would introduce new bugs.</li>
							<li>Reduce the cost of a business change requirement.</li>
						</ul>
					</section>

					<section>
						<h2>Template Method Pattern</h2>
						<div class="r-fit-text">Create an abstract class containing the base logic, and create implementations of it for different behavior. If you want to add new behavior, you simply create a new class, derive from the base class and add the functionality. </div>
						<img src="./assets/template-method-pattern.png" />
					</section>

					<section>
						<h2>Decorator Pattern</h2>
						<div class="r-fit-text">If you want to extend functionality (do the original thing and something extra before and/or after) but not want to change the existing class.</div>
						<a href="https://alexnault.dev/open-closed-principle-in-functional-typescript">Example in React</a>
						<a href="https://dev.to/shadid12/why-apply-open-closed-principles-in-react-component-composition-26p1">Example in React</a>
						<img src="./assets/decorator-pattern.png" />
					</section>

					<section>
						<h2>Strategy Design Pattern</h2>
						<div class="r-fit-text">One way is to create an interface (or abstract class) for the behavior, implement the interface for a certain behavior and use the interface from the calling class. </div>
						<img src="./assets/strategy-design-pattern.png" />
						<div class="r-fit-text">The strategy design pattern is a great example that achieves the OCP in an elegant way. It is one of the most useful design patterns.</div>
						<aside class="notes">
							You have a problem that can be solved in multiple ways. These ways are called Strategies, every strategy encapsulates a different solution for the problem. All these strategies must implement one interface to solve this problem. This problem is in a class called Context. These strategies can be injected into the context in many ways like Dependency Injection, Factory Design Pattern, or simply, by If Condition.
							Now, your code is open for extensions as it enables you to use different strategies as long as they implement the required interface. And closed for modifications because the context class itself doesn’t have to be changed, it solves its problem with any strategy, no matter what exactly the strategy is.
					   </aside>
					</section>


					<section>
						<h2>References</h2>
						<ul class="r-fit-text">
							<li>https://blog.mayallo.com/open-closed-principle-the-hard-parts</li>
							<li>https://thevaluable.dev/open-closed-principle-revisited/</li>
							<li>https://stackoverflow.com/questions/59016/what-is-the-meaning-and-reasoning-behind-the-open-closed-principle</li>
							<li>https://www.devonblog.com/software-development/solid-violations-in-the-wild-the-open-closed-principle/</li>
							<li>https://ezzeddinabdullah.com/post/solid-principles-ocp-py/</li>
							<li>https://ericbackhage.net/clean-code/solid-the-open-closed-principle/</li>
							<li>https://www.devonblog.com/software-development/solid-violations-in-the-wild-the-open-closed-principle/</li>
							<li>https://waldemar.bearblog.dev/open-closed-principle/</li>
							<li>https://michalgodkowicz.medium.com/how-to-make-your-python-code-maintainable-with-the-open-close-principle-1860fecc8ec0</li>
						</ul>
					</section>

				</section>
				<section>
					<section>Liskov’s substitution principle</section>

					<section>
						<blockquote>
							If a derived class is to be implemented, the base class must be extended without changing the behavior of the base function
						</blockquote>
					</section>

					<section>
						<h2>What does that mean?</h2>
						<div>
							In simpler terms, subclasses must behave like base classes.
						</div>
					</section>

					<section>
						<h2>Benefits</h2>
						<ul>
							<li>
								 Security that an implementation can be replaced without changing its behavior.
							</li>
						</ul>
					</section>

				</section>

				<section>
					<section>Interface Segregation Principle</section>

					<section>
						<blockquote>
							Each class should be focused on one aspect or topic only
						</blockquote>
					</section>

					<section>
						<h2>What does that mean?</h2>
						<div>
							The Interface Segregation Principle deals with the separation or decoupling of classes. In the Open-Closed Principle, we learned to work with interfaces. However, interfaces are not without problems either, as they usually tend to get bigger and bigger. As a result, it becomes increasingly difficult to provide a complete implementation as more and more code needs to be added.
						</div>
					</section>

					<section>
						<h2>The solution?</h2>
						<div>
							Do not let interfaces become large in the first place and divide them into many small interfaces beforehand. This allows much more targeted interfaces to be defined externally.
						</div>
					</section>

					<section>
						<h2>Benefits</h2>
						<ul>
						️    <li>Simplifies reuse, testing, and maintenance by sharing responsibilities</li>
						    <li>Insulates classes from errors by introducing clear boundaries</li>
							<li>Allows functions to be replaced without having to understand related classes</li>
							<li>Lowers cognitive load by isolating topics</li>
							<li>Focuses attention on a single aspect</li>
						</ul>
					</section>

				</section>

				<section>
					<section>
						<h2>Dependency Inversion Principle</h2>
					</section>

					<section>
						<h2>Higher level classes should not depend on lower level classes</h2>
					</section>
				</section>

				<section>
					<h2>References</h2>
					<ul>
						<li>
							https://camao-tec.com/en/solid-principles-easily-explained/
						</li>
						<li>
							https://www.pythontutorial.net/python-oop/python-open-closed-principle/
						</li>
					</ul>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/reveal.js-mermaid-plugin@1.1.0/plugin/mermaid/mermaid.js"></script>

		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMermaid ]
			});
		</script>
	</body>
</html>
